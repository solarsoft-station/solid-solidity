# Avoid sharing a secret on-chain

Ethereum is a public blockchain; hence, all the transaction data is visible to everyone. To execute a function on a contract, a user has to sign the function data from their EOA and send it to the Ethereum blockchain. In this process, the signed data contains the first four bytes of the function signature followed by the function arguments. This data is visible, and anyone can see the function definition as well, if the code of the contract is published on the block explorer.

If you have a contract that requires confidential data to be sent, it would be visible to everyone, and would not remain private when a transaction is initiated. As the Ethereum blockchain processes transactions slowly, you can see the transaction data and can initiate another transaction. For example, in the game Rock-Paper-Scissors, two players each select one of three options at random, and one wins the game. But if player 2 knows the option chosen by player 1, then player 2 can select the right option so that he/she wins the game all the time:

```
contract RockPaperScissor
{
    enum Choice {NONE, ROCK, PAPER, SCISSOR}

    struct PlayerChoice {
        address player;
        Choice choice;
    }

    PlayerChoice[2] players;

    function registerPlayer() public {
        if(players[0].player == address(0))
            players[0].player = msg.sender;

        if(players[1].player == address(0))
            players[1].player = msg.sender;

        revert("All players registered");
    }

    function play(Choice _choice) public {
        uint index = validateAndfindPlayerIndex();
        players[index].choice = _choice;
    }

    function checkWinner() public {
        //Code to check winner and reward
    }

    function validateAndfindPlayerIndex() internal returns (uint) {
        if(
            players[0].player == msg.sender &&
            players[0].choice == Choice.NONE
        ) return 0;

        if(
            players[1].player == msg.sender &&
            players[1].choice == Choice.NONE
        ) return 1;

        revert("Invalid call");
    }
}
```

As you can see in the preceding sample code of the RockPaperScissor contract, when the play() function is called by player 1, their choice is published on the chain, and player 2 can see player 1's choice. Now player 2 can select a choice so that they always win the game.

To overcome this problem, you can use the commit-and-reveal scheme, in which all the players first share a secret hash, and, once all the players have submitted the secret hash, they all reveal their secret by sharing the salt in the reveal transaction.

## The commit-and-reveal scheme

In the commit-and-reveal scheme, first, a hash of the original secret is submitted to the blockchain. This secret hash is recorded and stored on-chain in the contract. Once all the players or parties have submitted their secret hash, they all have to reveal their choice by submitting salt, using which they have generated the secret hash. A salt is like a password; using this an user can generate a secret hash. This secret is generated by combining the data (to be hidden) and salt and taking hash of this combined data. You can use any hashing algorithm to generate hashes. We have used keccak256 hashing algorithm in the sample code

This way of first committing the secret hash and later revealing it prevents players from sharing their original choice. Let's look at the updated code of RockPaperScissor:

```
contract RockPaperScissor
{
    //Rest of the exiting code

    struct PlayerChoice {
        address player;
        bytes32 commitHash;
        Choice choice;
    }

    function play(bytes32 _commitHash) public {
        uint index = validateAndFindPlayerIndex();
        players[index].commitHash = _commitHash;
    }

    function reveal(Choice _choice, bytes32 _salt) public {
        require(
            players[0].commitHash != 0x0 &&
            players[1].commitHash != 0x0
        );
        uint index = findPlayerIndex();
        require(players[index].commitHash ==
            getSaltedHash(_choice, _salt));
        players[index].choice = _choice;
    }

    function getSaltedHash(Choice _answer, bytes32 _salt)
        internal view returns (bytes32) {
        return keccak256(abi.encodePacked(address(this), _answer, _salt));
    }
}
```

In the preceding code, using the play() function, a player is submitting his secret commit hash. Once all the players have submitted their commit hashes, each player should call the reveal() function to reveal their choices.

There are some guidelines you must follow for salt usage:

- The salt that you have revealed on-chain must not be used again in future transactions. It must be different each time.
- The salt must be strong enough in terms of number of characters used, so that it becomes difficult to brute-force.
- If you have used salt while testing on the testnet chain, you should not use the same salt again on the mainnet chain.
- You must keep you salt stored at secret location until it's revealed.
